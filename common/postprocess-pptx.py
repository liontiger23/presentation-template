#!/usr/bin/env python3

# Generated by Deepseek AI

import re
import zipfile
import os
import shutil
import sys
import tempfile
import uuid
from xml.etree import ElementTree as ET

# Configuration
LAYOUT_MARKER = r"\[LAYOUT:([^\]]+)\]"  # Matches [LAYOUT:Thank You], [LAYOUT:Custom] etc.

def build_layout_map(pptx_dir):
    """Build mapping of layout names to numbers by inspecting slideLayout files"""
    layout_map = {}
    layout_dir = os.path.join(pptx_dir, "ppt", "slideLayouts")

    if not os.path.exists(layout_dir):
        print(f"Error: Could not find slideLayouts directory", file=sys.stderr)
        return None

    # Register namespaces
    ns = {
        'p': 'http://schemas.openxmlformats.org/presentationml/2006/main',
        'a': 'http://schemas.openxmlformats.org/drawingml/2006/main'
    }

    # Scan all slideLayout files
    for layout_file in os.listdir(layout_dir):
        if not layout_file.startswith('slideLayout') or not layout_file.endswith('.xml'):
            continue

        try:
            layout_path = os.path.join(layout_dir, layout_file)
            tree = ET.parse(layout_path)
            root = tree.getroot()

            # Get layout name from cSld element
            cSld = root.find('.//p:cSld', ns)
            if cSld is not None:
                layout_name = cSld.get('name')
                if layout_name:
                    # Extract layout number from filename (slideLayout11.xml -> 11)
                    layout_num = ''.join(filter(str.isdigit, layout_file))
                    if layout_num:
                        layout_map[layout_name] = int(layout_num)

        except ET.ParseError as e:
            print(f"Warning: Could not parse {layout_file} - {str(e)}", file=sys.stderr)
            continue

    return layout_map

def process_pptx(input_pptx, output_pptx):
    # Create unique temporary directory
    temp_dir = os.path.join(tempfile.gettempdir(), f"pptx_mod_{uuid.uuid4().hex}")
    os.makedirs(temp_dir, exist_ok=True)

    try:
        # 1. Extract source PPTX
        with zipfile.ZipFile(input_pptx, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # 2. Build layout name-to-number mapping
        layout_map = build_layout_map(temp_dir)
        if not layout_map:
            print("Error: No valid layouts found in template", file=sys.stderr)
            return False

        # 3. Process each slide
        slide_dir = os.path.join(temp_dir, "ppt", "slides")
        for slide_file in sorted(os.listdir(slide_dir)):
            if not slide_file.startswith('slide') or not slide_file.endswith('.xml'):
                continue

            slide_path = os.path.join(slide_dir, slide_file)
            slide_num = slide_file[5:-4]
            rels_path = os.path.join(temp_dir, "ppt", "slides", "_rels", f"{slide_file}.rels")

            # 4. Process slide XML as text
            with open(slide_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Find title text
            title_match = re.search(r'<a:t>([^<]+)</a:t>', content)
            if title_match:
                title_text = title_match.group(1)
                # Check for layout marker
                layout_match = re.search(LAYOUT_MARKER, title_text)
                if layout_match:
                    layout_name = layout_match.group(1)

                    # Find layout number by name
                    if layout_name not in layout_map:
                        print(f"Error: Layout '{layout_name}' not found. Available layouts: {list(layout_map.keys())}", file=sys.stderr)
                        return False

                    layout_num = layout_map[layout_name]

                    # Remove marker from title
                    new_title = re.sub(LAYOUT_MARKER, "", title_text).strip()
                    content = content.replace(title_match.group(0), f'<a:t>{new_title}</a:t>')

                    # Remove existing layout references
                    content = re.sub(r'<p:sldLayoutIdLst>.*?</p:sldLayoutIdLst>', '', content, flags=re.DOTALL)

                    # Add new layout reference
                    new_layout = f'''<p:sldLayoutIdLst><p:sldLayoutId id="256" r:id="rId{layout_num}"/></p:sldLayoutIdLst>'''
                    content = content.replace('<p:sld>', '<p:sld>' + new_layout)

                    # Save modified content
                    with open(slide_path, 'w', encoding='utf-8') as f:
                        f.write(content)

                    # Force relationship update
                    if os.path.exists(rels_path):
                        with open(rels_path, 'r+', encoding='utf-8') as f:
                            rels_content = f.read()
                            # Remove any existing layout relationship
                            rels_content = re.sub(
                                r'<Relationship [^>]*slideLayout[^>]*>', 
                                '', 
                                rels_content
                            )
                            # Add new relationship
                            new_rel = f'''<Relationship Id="rId{layout_num}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" Target="../slideLayouts/slideLayout{layout_num}.xml"/>'''
                            rels_content = rels_content.replace('</Relationships>', new_rel + '</Relationships>')
                            f.seek(0)
                            f.write(rels_content)
                            f.truncate()

        # Rebuild PPTX
        with zipfile.ZipFile(output_pptx, 'w', zipfile.ZIP_DEFLATED) as zip_out:
            for root, _, files in os.walk(temp_dir):
                for file in files:
                    path = os.path.join(root, file)
                    arcname = os.path.relpath(path, temp_dir)
                    zip_out.write(path, arcname)

        #print(f"Successfully processed {output_pptx}")
        #print(f"Layouts available: {layout_map}")
        return True

    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        return False
    finally:
        # Clean up temporary directory
        if os.path.exists(temp_dir):
            try:
                shutil.rmtree(temp_dir)
            except Exception as e:
                print(f"Warning: Could not clean up temporary directory {temp_dir} - {str(e)}", file=sys.stderr)

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python pptx_marker_processor.py <input.pptx> <output.pptx>")
        sys.exit(1)

    success = process_pptx(sys.argv[1], sys.argv[2])
    sys.exit(0 if success else 1)
